<head>
	<!--<script src="https://code.jquery.com/jquery-3.2.1.min.js"
			  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
			  crossorigin="anonymous"></script>-->
	<script src="/scripts/jquery-2.2.2.js"></script>
	<script src="/node_modules/axios/dist/axios.js"></script>
	<script>
	
	const hostController = 'noiselab.censeo.local:3000'; //IPv6 Host - 
//Establish Telnet connection via get()
    function connectBFhost(c) {
        axios.get("http://" + hostController + "/" + c)
		.then(function (response) {
          console.log(response);
        })
        .catch(function (error) {
          console.log(error);
        });
    }
//Control route via post()
    function controlBF(cmd) {
        axios.post("http://" + hostController + "/" + cmd)
		.then(function (response) {
			console.log(res);
        })
        .catch(function (error) {
          console.log(error);
        });
    } 
//Log project route.....in progress
    function logEvent() {
        axios.post("http://" + hostParam + "/api",{
            logID: "Log ID",
            projectID: "Censeo Project",
			phase: "CD Phase",
			location: "Waiea", // this can be related to projectID
			component: "Component ID",  //in this case, some window formatted from BIM model
            detail: "Detail ID" // in this case a JSON object that relates to BIM model
		})
		.then(res => {
			console.log(res);
        })
        .catch(function (error) {
            console.log(error);
        });
    }
	</script>

	<script>
var TypeUnknown = 0;
var TypeInt = 1;
var TypeUInt = 2;
var TypeFloat = 3;
var TypeFloatSeries = 4;
var TypeFloatWithFlags = 5;
var TypeString = 6;
var TypeByteSeries = 7;
var TypeUIntSeries = 8;
var TypeEnum = 9;
var TypeUIntWithFlags = 10;
var TypeFloatWithFlagsSeries = 11;


var WebSocketComm = {
	StatusUpdate: null,
	DataUpdate: null,
	RegisterStatusHandler: function () { },
	UnregisterStatusHandler: function () { },
	RegisterDataHandler: function () { },
	UnregisterDataHandler: function () { },
	RegisterConnHandler: function () { },
	UnregisterConnHandler: function () { },
	SysPropUpdate: null,
	EventHandler: null,
	Connected: false,
	dataRate: 250,
	init: function () {
		var statusHandler = [];
		var dataHandler = [];
		var connHandler = [];
		var self = WebSocketComm;

		var avg, last, count = 0;
		var lastMessageTimeStamp;

		// check to see if we are DirectIO and return if so.
		if (!OnMeter) {
			return;
		}
		// Adding the /ws so nginx is happy, we will likely be using
		// nginx to serve the files so hld does not have to do that anymore.
		try {
			var ws = new WebSocket("ws://" + location.host + "/ws");
			self.RegisterStatusHandler = function (handler) {
				Register(handler, statusHandler);
			}
			self.UnregisterStatusHandler = function (handler) {
				Unregister(handler, dataHandler);
			}
			self.RegisterDataHandler = function (handler) {
				Register(handler, dataHandler);
			}
			self.UnregisterDataHandler = function (handler) {
				Unregister(handler, dataHandler);
			}
			self.RegisterConnHandler = function (handler) {
				Register(handler, connHandler);
			}
			self.UnregisterConnHandler = function (handler) {
				Unregister(handler, connHandler);
			}
			self.Reconnect = function () {
				if (!self.Worked) {
					wsOld = ws;
					if (wsOld.readyState == ws.OPEN) {
						wsOld.close();
					}
					ws = new WebSocket("ws://" + location.host + "/ws");
					ws.onopen = wsOld.onopen;
					ws.onclose = wsOld.onclose;
					ws.onerror = wsOld.onerror;
					ws.onmessage = wsOld.onmessage;
				}
				self.Worked = false;
				self.reconnecting = true;
				setTimeout(function () {
					if (!self.Worked) {
						self.Reconnect();
					}
				}, 2000);
			}
			self.Send = function (message) {
				try {
					ws.send(message);
				}
				catch (e) {
					console.log("ws.send failed.");
				}
			}
			self.SetDataNeeded = function (json) {
				json.command = "setdata";
				self.Send(JSON.stringify(json));
			}
			self.SetDataRate = function (timer) {
				var json = {};
				//avg = timer;
				//count = 0;
				//last = undefined;
				if (timer > 0) {
					json.rate = timer;
					self.dataRate = timer;
					json.command = "dataon"
				}
				else {
					json.command = "dataoff";
				}
				self.Send(JSON.stringify(json));
			}
			self.SetStatusRate = function (timer) {
				var json = {};
				if (timer > 0) {
					json.rate = timer;
					json.command = "statuson"
				}
				else {
					json.command = "statusoff";
				}
				self.Send(JSON.stringify(json));
			}
			function Register(handler, set) {
				set.push(handler);
			}
			function Unregister(handler, set) {
				var i = set.lastIndexOf(handler);
				if (i > -1) {
					set.splice(i, 1);
				}
			}
			function Invoke(set, parameter) {
				var handled = false;
				for (var i = 0, len = set.length; i < len; ++i) {
					if (set[i] !== undefined) {
						set[i](parameter);
						handled = true;
					}
				}
				if (!handled) {
					console.log("Unhandled WS event: " + parameter);
				}
				return handled;
			}
			function watchDog(myWs) {
				if (ws === myWs) {
					if (Date.now() - lastMessageTimeStamp > 10000 && self.Connected) {
						console.log("Watch Dog said 'Bark, Bark' at " + new Date().toTimeString());
						myWs.close();
						self.Worked = false;
						delete self.GetID;
						self.Reconnect();
					}
					else if (self.Connected) {
						setTimeout(watchDog, 5000, myWs);
					}
				}
			}
			ws.onopen = function () {
				self.Connected = true;
				var beforeunload = window.onbeforeunload;
				var _this = this;
				window.onbeforeunload = function () {
					_this.close();
					if (beforeunload != undefined) {
						beforeunload();
					}
				}
				Invoke(connHandler, "{status:'" + this.readyState + "'}");
				lastMessageTimeStamp = Date.now();
				setTimeout(watchDog, 20000, _this);
			}
			ws.onclose = function (e) {
				if (self.GetID !== undefined && self.GetID() == this.sockID) {
					delete self.GetID;
					self.Connected = false;
					this.close();
					Invoke(connHandler, "{status:'" + this.readyState + "'}");
					console.log(e);
					//centralTimer();
					//wDogTimer();
				}
			}
			ws.onerror = function (e) {
				Invoke(connHandler, "{status:'" + (self.Connected ? "Connected" : "Disconnected") + "', message:'An error occured with the WebSocket.'}");
			}
			var last = new Date().getTime();
			// function to call in onmessage
			// TODO: move out of Try Catch
			ws.onmessage = function (msg) {
				try {
					//Messaging(msg);
					lastMessageTimeStamp = Date.now();
					self.Worked = true;

					var message = JSON.parse(msg.data);

					if (message.Status !== undefined) {
						Invoke(statusHandler, message.Status);
					}

					if (message.Data !== undefined) {
						if (message.Force) {
							message.Data.Force = true;
						}

						var time = new Date().getTime();
						last = time;
						Invoke(dataHandler, message.Data);
					}

					if (message.sockID !== undefined) {
						var sockID = this.sockID = message.sockID;

						if (self.GetID === undefined) {
							self.GetID = function () { return sockID; };
							self.SetStatusRate(1000);
							//$.getJSON("/sdk?func=refreshrate&sock=" + sockID + "&status=1000").done(function (data) { CurrentStatus = GenerateCache(data.Status); });

							if (!isStarting) {
								setTimeout(function () {
									refreshViewData();
								}, 1000);
							}
						}
					}

					if (message.Connected !== undefined) {
						console.log("HLD can no longer communicate with the meter.")
					}

					if (message.Warning !== undefined) {
						console.log(message);
					}

					if (self.GetID() !== this.sockID) {
						console.log("Closing down socket: " + this.sockID);
						this.close();
					}
				}
				catch (e) {
					console.log(e);
				}
			}
		}
		catch (e) {
			console.log(e);
		}
	}
};

Number.prototype.toHHMMSS = function () {
	var sec_num = parseInt(this, 10); // don't forget the second param
	var hours   = Math.floor(sec_num / 3600);
	var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
	var seconds = sec_num - (hours * 3600) - (minutes * 60);

	hours = hours % 24
	if (hours   < 10) {hours   = "0"+hours;}
	if (minutes < 10) {minutes = "0"+minutes;}
	if (seconds < 10) {seconds = "0"+seconds;}
	return hours+':'+minutes+':'+seconds;
}

WebSocketComm.RegisterConnHandler(function (msg) {
	console.log(msg);
});

window.OnMeter = true;
window.isStarting = true;

WebSocketComm.init();

WebSocketComm.RegisterStatusHandler(function (d) {
	$("#time").html(d.tv_sec.toHHMMSS());
});
// rev
WebSocketComm.RegisterDataHandler(function (d) {
	var len = d.length;
		for (var i = 0; i < len; ++i) {
		if (d[i].value instanceof Array) {
			$("#" + d[i].name).html(getArrayStr(d[i].value));
		}
		else
		{
			$("#" + d[i].name).html(d[i].value.toFixed(2));
			// Determine triggering
			let myObj = d[i].value;
					trigger = parseInt(myObj)
					console.log("Event Trigger State:" + trigger);
					if (trigger == 4) {
						let cmd = 'seq';
						console.log("Trigger Sent to BEAMFORM");
						controlBF(cmd);
						} else {
						return
						}
	     }
}
});

var regObj = { "Registering": [] };
var regisertingArray = regObj.Registering;

function AddDataPoint(tag, group, name, type) {
	var len = regisertingArray.length;
	var groupJson = undefined;
	for (var i = 0; i < len; ++i) {
		if (regisertingArray[i].g == group) {
			groupJson = regisertingArray[i];
		}
	}
	if (groupJson === undefined) {
		groupJson = { g: group, i: 0 };
		regisertingArray.push(groupJson);
	}

	if (groupJson.tags == undefined) {
		groupJson.tags = [];
	}
	groupJson.tags.push({ "tp": type, "tg": tag, "n": name });

	WebSocketComm.SetDataNeeded(regObj);
	WebSocketComm.SetDataRate(250);
	$("#jsonData").html(JSON.stringify(regObj));
}

function RemoveDataPoint(name) {
	var len = regisertingArray.length;
	var groupJson = undefined;
	for (var i = 0; i < len; ++i) {
		var len2 = regisertingArray[i].tags.length;
		for (var i2 = 0; i2 < len2; ++i2) {
			if (regisertingArray[i].tags[i2].n == name) {
				console.log(regisertingArray[i].tags);
				regisertingArray[i].tags.splice(i2, 1);
				console.log(regisertingArray[i].tags);
				var len2 = regisertingArray[i].tags.length;
				--i2;
			}
		}
	}

	WebSocketComm.SetDataNeeded(regObj);
	$("#jsonData").html(JSON.stringify(regObj));
}

function clearAdd() {
	$("#tagID").val("");
	$("#typeSel").val("TypeInt");
	$("#groupSel").val("live");
	$("#tagName").val("");
}

function getArrayStr(arr) {
	var res = "";
	var len = arr.length;
	for (var i = 0; i < len; ++i) {
		if (i > 0) {
			res += ", ";
		}
		if (arr[i] instanceof Object) {
			res += arr[i].val.toFixed(2);
		}
		else {
			res += arr[i].toFixed(2);
		}
	}
	return res;
}

function start() {
  let c = 'c';
  connectBFhost(c);
	setTimeout(function () {
		$("#dataView").on("change", "input[type='checkbox']", function () {
			if (this.checked) {
				var sel = $(this);
				AddDataPoint(parseInt(sel.data("tag")), sel.data("group"), sel.data("name"), window[sel.data("type")]);
			}
			else {
				var sel = $(this);
				RemoveDataPoint(sel.data("name"));
				$("#" + sel.data("name")).html("");
			}
		});
	}, 1000);

	$("#addCustomTag").on("click", function () {
		$("#addCustomForm").show();
		$("#addCustomTag").hide();
	});
	$("#addDone").on("click", function () {
		$("#addCustomForm").hide();
		$("#addCustomTag").show();

		var nameStr = $("#tagName").val();
		var typeStr = $("#typeSel option:selected").text();
		var groupStr = $("#groupSel option:selected").text();
		var tagStr = $("#tagID").val()

		if (nameStr != "" && typeStr != "" && tagStr != "" && groupStr != "") {
			var dataView = document.getElementById("dataView");
			var row = dataView.insertRow(1);
			var name = row.insertCell(0);
			var tagId = row.insertCell(1);
			var type = row.insertCell(2);
			var group = row.insertCell(3);
			var getCB = row.insertCell(4);
			var valueField = row.insertCell(5);

			name.innerHTML = (nameStr);
			tagId.innerHTML = (tagStr);
			type.innerHTML = (typeStr);
			group.innerHTML = (groupStr);
			getCB.innerHTML = ('<input type="checkbox" data-group="' + groupStr + '" data-tag="' + tagStr + '" data-name="' + nameStr + '" data-type="' + typeStr + '" />');
			valueField.id = (nameStr);
		}
		clearAdd();
	});
	$("#addCancel").on("click", function () {
		$("#addCustomForm").hide();
		$("#addCustomTag").show();
		clearAdd();
	});
}
</script>
<style>
.yes {
display: inline;
padding: 1px 10px;
color: white;
text-decoration: none;
border-top: 2px solid #B7BCBD;
border-left: 2px solid rgba(113, 236, 255, 0.4);
border-right: 2px solid rgba(113, 236, 255, 0.4);
border-bottom: 2px solid rgba(3, 24, 42, 0.8);
font-size: 12px;

border-radius: 2px;
background: #47A0E9;
background: -webkit-linear-gradient(top, #47A0E9 0%, #1F72B6 50%, #0C5692 51%, #002346 100%);
background: -moz-linear-gradient(top, #47A0E9 0%, #1F72B6 50%, #0C5692 51%, #002346 100%);
background: -ms-linear-gradient(top, #47A0E9 0%, #1F72B6 50%, #0C5692 51%, #002346 100%);
background: -o-linear-gradient(top, #47A0E9 0%, #1F72B6 50%, #0C5692 51%, #002346 100%);
background: linear-gradient(to bottom, #47A0E9 0%, #1F72B6 50%, #0C5692 51%, #002346 100%);
}
</style>
</head>
<title>
WebSocket Event State stream and BeamformX trigger
</title>
<body style="background:#181818; color: #26b3f7; font-family:'Arial',Geneva,Verdana,sans-serif;" onload="start()">
<div>
<table id="dataView">
	<tr>
		<td>Event-State</td>
		<td>0x54535645</td>
		<td>TypeUInt</td>
		<td>live</td>
		<td><input type="checkbox" data-group="live" data-tag="0x54535645" data-name="Event-State" data-type="TypeUInt" /></td>
		<td id="Event-State"></td>
	</tr>
</table>
<br />
<div id="addCustomTag" class="yes" style="float:left; margin:3px; padding:3px; cursor:pointer;">Add Custom</div>
<br />
<br />
<div style="display:none;" id="addCustomForm">
	<table>
		<tr>
			<td>Name</td>
			<td><input type="text" id="tagName" /></td>
		</tr>
		<tr>
			<td>Tag ID</td>
			<td><input type="text" id="tagID" /></td>
		</tr>
		<tr>
			<td>Type</td>
			<td>
				<select id="typeSel">
					<option>TypeInt</option>
					<option>TypeUInt</option>
					<option>TypeFloat</option>
					<option>TypeFloatSeries</option>
					<option>TypeFloatWithFlags</option>
					<option>TypeString</option>
					<option>TypeEnum</option>
					<option>TypeUIntWithFlags</option>
					<option>TypeFloatWithFlagsSeries</option>
				</select>
			</td>
		</tr>
		<tr>
			<td>Group</td>
			<td>
				<select id="groupSel">
					<option>live</option>
					<option>overall</option>
					<option>current</option>
					<option>timehistory</option>
					<option>fileoverall</option>
					<option>measurement</option>
					<option>filemeasurement</option>
					<option>filetimehistory</option>
				</select>
			</td>
		</tr>
	</table>
	<div style="display:inline-block">
		<div class="yes" style="float:left; margin:3px; padding:3px; cursor:pointer" id="addDone">Add</div>
		<div class="yes" style="float:left; margin:3px; padding:3px; cursor:pointer" id="addCancel">Cancel</div>
	</div>
</div>
<br />
<div>JSON sent to the WebSocket:</div>
<div style="color: #f0f0f0" id="jsonData"></div>
<br />
<br />
<div style="color: #c0c0c0">NOTES:</div>
</div>
</body>
